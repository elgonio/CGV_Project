<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>COMS3006 Game</title>
<link rel="stylesheet" href="css/style.css">
<script src="plugins/threejs/three.js"></script>
<script src="plugins/threejs/OrbitControls.js"></script>
<script src="plugins/threejs/stats.min.js"></script>
<script src="js/player.js"></script>
<script src="js/tracklines.js"></script>
<script src="js/level.js"></script>
<script src="js/block.js"></script>
<script>

"use strict";
var stats;
var canvas, renderer, scene, camera; // Standard three.js requirements.

var controls;  // An OrbitControls object that is used to implement
               // rotation of the scene using the mouse.  (It actually rotates
               // the camera around the scene.)

var animating = false;  // Set to true when an animation is in progress.
var frameNumber = 0;  // Frame number is advanced by 1 for each frame while animating.

document.addEventListener( 'keydown', onKeyDown, false );
document.addEventListener( 'keyup', onKeyUp, false );

// we declare variables for our balls
// this way they are global and we can manipulate them from anywhere
var red_ball ;
var yellow_ball ;
var blue_ball ;
var tracks ;
var level_Manager ;

function debug()
{
    console.log(red_ball.colour);
    console.log(red_ball.dest);
    console.log(red_ball.sphere.position.x);
    console.log(red_ball.isMoving)
}
// here we detect when a key is pressed down or up
// A full list can be found at: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes
function onKeyDown( event ) {
    event.stopPropagation();

    

    switch ( event.keyCode ) {
        case 87: /*W*/ blue_ball.controls.moveForward = true; break;
        case 83: /*S*/ blue_ball.controls.moveBackward = true; break;
        case 65: /*A*/ blue_ball.controls.moveLeft = true; break;
        case 68: /*D*/ blue_ball.controls.moveRight = true; break;

        case 73: /*I*/ red_ball.controls.moveForward = true; break;
        case 75: /*K*/ red_ball.controls.moveBackward = true; break;
        case 74: /*J*/ red_ball.controls.moveLeft = true; break;
        case 76: /*L*/ red_ball.controls.moveRight = true; break;

        case 38: /*up*/yellow_ball.controls.moveForward = true; break;
        case 40: /*down*/yellow_ball.controls.moveBackward = true; break;
        case 37: /*left*/yellow_ball.controls.moveLeft = true; break;
        case 39: /*right*/yellow_ball.controls.moveRight = true; break;

        case 32: /*SPACEBAR*/ debug();break;
    }
    
}
function onKeyUp( event ) {
    event.stopPropagation();
    switch ( event.keyCode ) {
        case 87: /*W*/ blue_ball.controls.moveForward = false; break;
        case 83: /*S*/ blue_ball.controls.moveBackward = false; break;
        case 65: /*A*/ blue_ball.controls.moveLeft = false; break;
        case 68: /*D*/ blue_ball.controls.moveRight = false; break;

        case 73: /*I*/ red_ball.controls.moveForward = false; break;
        case 75: /*K*/ red_ball.controls.moveBackward = false; break;
        case 74: /*J*/ red_ball.controls.moveLeft = false; break;
        case 76: /*L*/ red_ball.controls.moveRight = false; break;

        case 38: /*up*/yellow_ball.controls.moveForward = false; break;
        case 40: /*down*/yellow_ball.controls.moveBackward = false; break;
        case 37: /*left*/yellow_ball.controls.moveLeft = false; break;
        case 39: /*right*/yellow_ball.controls.moveRight = false; break;
    }
    //console.log("KEY_UP")    
}
                
// here we have some helper functions that were present in the lab that this code was adapted from

function makeTexture(imageURL, material) {
    function callback() { // Function to react when image load is done.
        if (material) {
            material.map = texture;  // Add texture to material.
            material.needsUpdate = true;  // Required when material changes.
        }
        render();  // Render scene with texture that has just been loaded.
    }
    var texture = THREE.ImageUtils.loadTexture(imageURL, undefined, callback);
    return texture;
}

function loadModel(modelURL,target,scale_factor) {
    function callback(geometry) {
        // To be executed when the model has fully loaded.  The parameter
        // is geometry that can be used for a THREE.Mesh object.
        var object = new THREE.Mesh(geometry,materialWithCloudTexture);
        object.scale.set(scale_factor, scale_factor, scale_factor); 
        target.add(object);
        //render();  // Render the scene with the newly added objects.
        
    }
    var loader = new THREE.JSONLoader();
    try {
        loader.load(modelURL, callback);
    }
    catch (e) {
        // Note: Chrome gives an error if loading from local file system.
        console.log("Error loading model from " + modelURL);
    }
}

// The commented lines change the color of the balls in addition to changing the emissive colours
function handleColours()
{
    // BACK TO NORMAL
    red_ball.sphere.material.emissive.setHex(0xdd0000);
    yellow_ball.sphere.material.emissive.setHex(0xdddd00);
    blue_ball.sphere.material.emissive.setHex(0x0000dd);

    if(red_ball.dest == yellow_ball.dest && red_ball.dest== blue_ball.dest)
    {
        //WHITE
        red_ball.sphere.material.emissive.setHex(0xcccccc);
        yellow_ball.sphere.material.emissive.setHex(0xcccccc);
        blue_ball.sphere.material.emissive.setHex(0xcccccc);
        
    }
    else if(red_ball.dest== yellow_ball.dest)
    {
        //ORANGE
        red_ball.sphere.material.emissive.setHex(0xce6800);
        yellow_ball.sphere.material.emissive.setHex(0xce6800);
    }
    else if(red_ball.dest == blue_ball.dest)
    {
        //PURPLE
        red_ball.sphere.material.emissive.setHex(0xdd00dd);
        blue_ball.sphere.material.emissive.setHex(0xdd00dd);

    }
    else if(blue_ball.dest == yellow_ball.dest)
    {
        //GREEN
        blue_ball.sphere.material.emissive.setHex(0x00dd00);
        yellow_ball.sphere.material.emissive.setHex(0x00dd00);
    }
}

function handleMovement()
{
    red_ball.handleMovement();
    blue_ball.handleMovement();
    yellow_ball.handleMovement();
}


/**
 *  The render function draws the scene.
 */
function render() {
    renderer.render(scene, camera);
}


/**
 * This function is called by the init() method to create the world. 
 */
function createWorld() {
    
    renderer.setClearColor("black"); // Background color for scene.
    scene = new THREE.Scene();
    
    // ------------------- Make a camera with viewpoint light ----------------------
    
    camera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 500);
    camera.position.z = 25;
    camera.position.y = 9;
    camera.lookAt(new THREE.Vector3(0,-10,-60));

    
    var light;  // A light shining from the direction of the camera; moves with the camera.
    light = new THREE.DirectionalLight();
    light.position.set(0,0,1);
    camera.add(light);
    scene.add(camera);
    
    //------------------- Create the scene's visible objects ----------------------

    blue_ball = new PlayerBall("blue",0); //Start on far left
    scene.add(blue_ball.get_mesh());

    red_ball = new PlayerBall("red",2); //Start in the middle
    scene.add(red_ball.get_mesh());

    yellow_ball = new PlayerBall("yellow",4); //Start on far right
    scene.add(yellow_ball.get_mesh());

    tracks = new Tracks();
    scene.add(tracks.get_TrackMeshes());

    level_Manager = new LevelManager("easy", -200);

    level_Manager.instantiateRow(); //Delay this function in a loop so it continiously instatiates rows of obstacles

    scene.add(level_Manager.get_row());

//Testing adding a single block
/*
    var block = new BlockObstacle("white", 2, "standard");
    block.get_mesh().position.z = -200;
    scene.add(block.get_mesh());
*/

    render()
    
} // end function createWorld()


/**
 *  This function is called once for each frame of the animation, before
 *  the render() function is called for that frame.  It updates any
 *  animated properties.  The value of the global variable frameNumber
 *  is incrementd 1 before this function is called.
 */
function updateForFrame() {
    
    handleMovement();
    handleColours();

    stats.update();
    
}


/* ---------------------------- MOUSE AND ANIMATION SUPPORT ------------------

/**
 *  This page uses THREE.OrbitControls to let the user use the mouse to rotate
 *  the view.  OrbitControls are designed to be used during an animation, where
 *  the rotation is updated as part of preparing for the next frame.  The scene
 *  is not automatically updated just because the user drags the mouse.  To get
 *  the rotation to work without animation, I add another mouse listener to the
 *  canvas, just to call the render() function when the user drags the mouse.
 *  The same thing holds for touch events -- I call render for any mouse move
 *  event with one touch.
 */
function installOrbitControls() {
    controls = new THREE.OrbitControls(camera,canvas);
    controls.noPan = true; 
    controls.noZoom = true;
    controls.staticMoving = true;
    function move() {
        controls.update();
        if (! animating) {
            render();
        }
    }
    function down() {
        document.addEventListener("mousemove", move, false);
    }
    function up() {
        document.removeEventListener("mousemove", move, false);
    }
    function touch(event) {
        if (event.touches.length == 1) {
            move();
        }
    }
    canvas.addEventListener("mousedown", down, false);
    canvas.addEventListener("touchmove", touch, false);
}

/*  Called when user changes setting of the Animate checkbox. */
function doAnimateCheckbox() {
   var run = true;
   if (run != animating) {
       animating = run;
       if (animating) {
           requestAnimationFrame(doFrame);
       }
   }
}

/*  Drives the animation, called by system through requestAnimationFrame() */
function doFrame() {
    if (animating) {
        frameNumber++;
        updateForFrame();
        render();
        requestAnimationFrame(doFrame);
    }
}

/*----------------------------- INITIALIZATION ----------------------------------------

/**
 *  This function is called by the onload event so it will run after the
 *  page has loaded.  It creates the renderer, canvas, and scene objects,
 *  calls createWorld() to add objects to the scene, and renders the
 *  initial view of the scene.  If an error occurs, it is reported.
 */
function init() {

    stats = new Stats();
    document.body.appendChild( stats.domElement );  

    try {
        canvas = document.getElementById("glcanvas");
        canvas.width  = window.innerWidth;
        canvas.height = window.innerHeight;

        doAnimateCheckbox();
        renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: false
        });

        //Responsive canvas that scales with window size
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth,window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();
        })
    }
    catch (e) {
        document.getElementById("message").innerHTML="<b>Sorry, an error occurred:<br>" +
                e + "</b>";
        return;
    }
    document.getElementById("animateCheckbox").checked = false;
    document.getElementById("animateCheckbox").onchange = doAnimateCheckbox;
    createWorld();
    // we don't actually need to change the camera view
    //installOrbitControls();
    render();

}

</script>
</head>

<body onload="init()">


<noscript>
   <p style="color: #AA0000; font-weight: bold">Sorry, but this page requires JavaScript!</p>
</noscript>

<p style="color:#AA0000; font-weight: bold" id="message">
</p>

<p>
    <!--removing the checkbox breaks things-->
   <label hidden><input type="checkbox" id="animateCheckbox"><b>Animate</b></label>
   <!--<b style="margin-left:50px">Use the mouse to rotate the model.</b>-->
</p>

<canvas width=1920 height=1080 id="glcanvas"></canvas>

</body>
</html>
