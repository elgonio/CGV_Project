<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>COMS3006 Game</title>
<script src="plugins/threejs/three.js"></script>
<script src="plugins/threejs/OrbitControls.js"></script>
<script src="plugins/threejs/stats.min.js"></script>
<script src="player.js"></script>
<script>

"use strict";
var stats;
var canvas, renderer, scene, camera; // Standard three.js requirements.

var controls;  // An OrbitControls object that is used to implement
               // rotation of the scene using the mouse.  (It actually rotates
               // the camera around the scene.)

var animating = false;  // Set to true when an animation is in progress.
var frameNumber = 0;  // Frame number is advanced by 1 for each frame while animating.

document.addEventListener( 'keydown', onKeyDown, false );
document.addEventListener( 'keyup', onKeyUp, false );

// we declare variables for our balls
// this way they are global and we can manipulate them from anywhere
var red_ball ;
var green_ball ;
var blue_ball ;

// these variables are checked in the animation loop to determine whether we should move the balls
var red_controls = {
    moveForward: false,
    moveBackward: false,
    moveLeft: false,
    moveRight: false
};

var blue_controls = {
    moveForward: false,
    moveBackward: false,
    moveLeft: false,
    moveRight: false
};

var green_controls = {
    moveForward: false,
    moveBackward: false,
    moveLeft: false,
    moveRight: false
};

// stuff for movement
var red_dest = 1;
var green_dest = 2;
var blue_dest = 3;

var destinations = [-10,-5,0,5,10];



// here we detect when a key is pressed down or up
// A full list can be found at: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes
function onKeyDown( event ) {
    event.stopPropagation();
    switch ( event.keyCode ) {
        case 38: /*up*/blue_controls.moveForward = true; break;
        case 87: /*W*/ 	red_controls.moveForward = true; break;
        case 40: /*down*/blue_controls.moveBackward = true; break;
        case 83: /*S*/ 	 red_controls.moveBackward = true; break;
        case 37: /*left*/blue_controls.moveLeft = true; break;
        case 65: /*A*/ red_controls.moveLeft = true; break;
        case 39: /*right*/blue_controls.moveRight = true; break;
        case 68: /*D*/ red_controls.moveRight = true; break;
    }
}
function onKeyUp( event ) {
    event.stopPropagation();
    switch ( event.keyCode ) {
        case 38: /*up*/
        case 87: /*W*/ red_controls.moveForward = false; break;
        case 40: /*down*/
        case 83: /*S*/ 	 red_controls.moveBackward = false; break;
        case 37: /*left*/
        case 65: /*A*/ 	 red_controls.moveLeft = false; break;
        case 39: /*right*/
        case 68: /*D*/ red_controls.moveRight = false; break;
    }
    //console.log("KEY_UP")    
}
                
// here we have some helper functions that were present in the lab that this code was adapted from

function makeTexture(imageURL, material) {
    function callback() { // Function to react when image load is done.
        if (material) {
            material.map = texture;  // Add texture to material.
            material.needsUpdate = true;  // Required when material changes.
        }
        render();  // Render scene with texture that has just been loaded.
    }
    var texture = THREE.ImageUtils.loadTexture(imageURL, undefined, callback);
    return texture;
}

function loadModel(modelURL,target,scale_factor) {
    function callback(geometry) {
        // To be executed when the model has fully loaded.  The parameter
        // is geometry that can be used for a THREE.Mesh object.
        var object = new THREE.Mesh(geometry,materialWithCloudTexture);
        object.scale.set(scale_factor, scale_factor, scale_factor); 
        target.add(object);
        //render();  // Render the scene with the newly added objects.
        
    }
    var loader = new THREE.JSONLoader();
    try {
        loader.load(modelURL, callback);
    }
    catch (e) {
        // Note: Chrome gives an error if loading from local file system.
        console.log("Error loading model from " + modelURL);
    }
}

//  this function makes a plain white ball with a white emissive light
function makeBall()
{
    var geometry = new THREE.SphereGeometry( 5, 32, 32 );
    var material = new THREE.MeshLambertMaterial( { color: 0xaaaaaa, 
                                                    emissive: 0xffffff,
                                                    emissiveIntensity: 1,
                                                    side: THREE.DoubleSide
                                                    } );
    var sphere = new THREE.Mesh( geometry, material );
    sphere.scale.set(0.5,0.5,0.5);

    return sphere;
}

// this function checks the x values of the balls
// we should probably change this to work off of the whole position
// I've done it this way because using red_ball.position == blue_ball.position didn't work for some reason

// The commented lines change the color of the balls in addition to changing the emissive colours
function handleColours()
{
    if(red_ball.position.x == green_ball.position.x && red_ball.position.x == blue_ball.position.x)
    {
        red_ball.material.emissive.setHex(0xffffff);
        green_ball.material.emissive.setHex(0xffffff);
        blue_ball.material.emissive.setHex(0xffffff);
        
    }
    else if(red_ball.position.x == green_ball.position.x)
    {
        red_ball.material.emissive.setHex(0xffff00);

        //red_ball.material.color.setHex(0xaaaa00);
        
        green_ball.material.emissive.setHex(0xffff00);
        //green_ball.material.color.setHex(0xaaaa00);

    }
    else if(red_ball.position.x == blue_ball.position.x)
    {
        red_ball.material.emissive.setHex(0xff00ff);
        //red_ball.material.color.setHex(0xff00ff);

        blue_ball.material.emissive.setHex(0xff00ff);
        //blue_ball.material.color.setHex(0xff00ff);

    }
    else if(blue_ball.position == green_ball.position)
    {
        blue_ball.material.emissive.setHex(0x00ffff);
        //blue_ball.material.color.setHex(0x00ffff);
        green_ball.material.emissive.setHex(0x00ffff);
        //green_ball.material.color.setHex(0x00ffff);
    }
    else 
    {
        red_ball.material.emissive.setHex(0xff0000);
        green_ball.material.emissive.setHex(0x00ff00);
        blue_ball.material.emissive.setHex(0x0000ff);
    }
}

function handleMovement()
{
    if (red_ball.position.x > destinations[red_dest])
    {
        red_ball.translateX(-1);
    }
    else if (red_ball.position.x < destinations[red_dest])
    {
        red_ball.translateX(1);
    }
}


/**
 *  The render function draws the scene.
 */
function render() {
    renderer.render(scene, camera);
}


/**
 * This function is called by the init() method to create the world. 
 */
function createWorld() {
    
    renderer.setClearColor("black"); // Background color for scene.
    scene = new THREE.Scene();
    
    // ------------------- Make a camera with viewpoint light ----------------------
    
    camera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 100);
    camera.position.z = 30;
    var light;  // A light shining from the direction of the camera; moves with the camera.
    light = new THREE.DirectionalLight();
    light.position.set(0,0,1);
    camera.add(light);
    scene.add(camera);
    
    //------------------- Create the scene's visible objects ----------------------
    /*
    red_ball = makeBall();
    red_ball.material.emissive.setHex(0xff0000)
    scene.add(red_ball);

    green_ball = makeBall();
    green_ball.translateX(7);
    green_ball.material.emissive.setHex(0x00ff00)
    scene.add(green_ball);

    blue_ball = makeBall();
    blue_ball.translateX(-7);
    blue_ball.material.emissive.setHex(0x0000ff)
    scene.add(blue_ball);
    */

    red_ball = new PlayerBall("red",3);
    red_ball = red_ball.get_model();
    scene.add(red_ball);



    render()
    
} // end function createWorld()


/**
 *  This function is called once for each frame of the animation, before
 *  the render() function is called for that frame.  It updates any
 *  animated properties.  The value of the global variable frameNumber
 *  is incrementd 1 before this function is called.
 */
function updateForFrame() {
    if (destinations.includes(red_ball.position.x))
    {
        console.log(red_dest);
        console.log(destinations[red_dest]);
        if (red_controls.moveLeft == true)
        {
            if(red_dest > 0)
            {
                red_dest = red_dest -1;
            }
        }
        else if (red_controls.moveRight == true)
        {
            if(red_dest < 5)
            {
                red_dest = red_dest +1;
            }
        }
    }

    
    handleMovement();
    handleColours();

    stats.update();
    
}


/* ---------------------------- MOUSE AND ANIMATION SUPPORT ------------------

/**
 *  This page uses THREE.OrbitControls to let the user use the mouse to rotate
 *  the view.  OrbitControls are designed to be used during an animation, where
 *  the rotation is updated as part of preparing for the next frame.  The scene
 *  is not automatically updated just because the user drags the mouse.  To get
 *  the rotation to work without animation, I add another mouse listener to the
 *  canvas, just to call the render() function when the user drags the mouse.
 *  The same thing holds for touch events -- I call render for any mouse move
 *  event with one touch.
 */
function installOrbitControls() {
    controls = new THREE.OrbitControls(camera,canvas);
    controls.noPan = true; 
    controls.noZoom = true;
    controls.staticMoving = true;
    function move() {
        controls.update();
        if (! animating) {
            render();
        }
    }
    function down() {
        document.addEventListener("mousemove", move, false);
    }
    function up() {
        document.removeEventListener("mousemove", move, false);
    }
    function touch(event) {
        if (event.touches.length == 1) {
            move();
        }
    }
    canvas.addEventListener("mousedown", down, false);
    canvas.addEventListener("touchmove", touch, false);
}

/*  Called when user changes setting of the Animate checkbox. */
function doAnimateCheckbox() {
   var run = true;
   if (run != animating) {
       animating = run;
       if (animating) {
           requestAnimationFrame(doFrame);
       }
   }
}

/*  Drives the animation, called by system through requestAnimationFrame() */
function doFrame() {
    if (animating) {
        frameNumber++;
        updateForFrame();
        render();
        requestAnimationFrame(doFrame);
    }
}

/*----------------------------- INITIALIZATION ----------------------------------------

/**
 *  This function is called by the onload event so it will run after the
 *  page has loaded.  It creates the renderer, canvas, and scene objects,
 *  calls createWorld() to add objects to the scene, and renders the
 *  initial view of the scene.  If an error occurs, it is reported.
 */
function init() {

    stats = new Stats();
    document.body.appendChild( stats.domElement );  

    try {
        canvas = document.getElementById("glcanvas");
        renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: false
        });
    }
    catch (e) {
        document.getElementById("message").innerHTML="<b>Sorry, an error occurred:<br>" +
                e + "</b>";
        return;
    }
    document.getElementById("animateCheckbox").checked = false;
    document.getElementById("animateCheckbox").onchange = doAnimateCheckbox;
    createWorld();
    installOrbitControls();
    render();

}

</script>
</head>
<body onload="init()">

<h2>_</h2>

<noscript>
   <p style="color: #AA0000; font-weight: bold">Sorry, but this page requires JavaScript!</p>
</noscript>

<p style="color:#AA0000; font-weight: bold" id="message">
</p>

<p>
   <label><input type="checkbox" id="animateCheckbox"><b>Animate</b></label>
   <b style="margin-left:50px">Use the mouse to rotate the model.</b>
</p>

<div id="canvas-holder" style="float:left; border: thin solid black; background-color: white">
   <canvas width=1200 height=600 id="glcanvas"></canvas>
</div>

</body>
</html>
