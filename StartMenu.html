<!DOCTYPE html>

<html lang="en">

<head>
    <title>three.js webgl - geometry - text</title>
    <meta charset="utf-8">
</head>

<body>
    <script src="plugins/threejs/three.js"></script>
    <script src="plugins/threejs/OrbitControls.js"></script>
    <script src="plugins/threejs/stats.min.js"></script>
    <script src="plugins/utils/GeometryUtils.js"></script>
    <script src="js/StartMenu.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/text.js"></script>
    <script src="plugins/WebGL.js"></script>
    <script src="js/StartMenuSkybox.js"></script>
    <script src="js/Sprity.js"></script>

    <script>
        if (WEBGL.isWebGLAvailable() === false) {
            document.body.appendChild(WEBGL.getWebGLErrorMessage());
        }
        document.addEventListener('keydown', onKeyDown, false);
        THREE.Cache.enabled = true;
        var p1, p2, p3;
        var t1, t2, t3;
        var returnToMain, returnToMainB;
        var textgroup, HelpRules;
        var canvas1, context1, texture1;

        var targetList = [];
        var raycaster, mouse = {
            x: 0,
            y: 0
        };
        var container, stats;
        var camera, cameraTarget, scene, renderer;
        var group, textMesh1, textMesh2, textGeo, materials, Newword;
        var state = 0;
        var text = "Colour Mix",
            height = 15,
            size = 50,
            hover = 10,
            curveSegments = 4,
            bevelThickness = 2,
            bevelSize = 1.5,
            bevelEnabled = true,
            font = undefined,
            fontName = "optimer",
            fontWeight = "bold";
        var windowHalfX = window.innerWidth / 2;
        var Players;
        var objects = [];
        var plane = new THREE.Plane();
        var raycaster = new THREE.Raycaster();
        // var mouse = new THREE.Vector2(),
        //     offset = new THREE.Vector3(),
        //     intersection = new THREE.Vector3(),
        //     INTERSECTED, SELECTED;


        init();
        animate();

        function decimalToHex(d) {
            var hex = Number(d).toString(16);
            hex = "000000".substr(0, 6 - hex.length) + hex;
            return hex.toUpperCase();
        }

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            // CAMERA
            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 1500);
            // camera = new THREE.PerspectiveCamera(30, canvas.width / canvas.height, 0.1, 500);
            // camera.position.z = 25;
            // camera.position.y = 9;
            // cameraTarget = new THREE.Vector3(0, -10, -60);
            camera.position.set(0, 400, 700);
            cameraTarget = new THREE.Vector3(0, 150, 0);
            // SCENE
            scene = new THREE.Scene();
            // scene.background = new THREE.Color(0x000000);

            // scene.fog = new THREE.Fog(0x000000, 250, 1400);
            // LIGHTS
            var dirLight = new THREE.DirectionalLight(0xffffff, 0.125);
            dirLight.position.set(0, 0, 1).normalize();
            scene.add(dirLight);
            var pointLight = new THREE.PointLight(0xffffff, 1.5);
            pointLight.position.set(0, 100, 150);
            /////////////////////////////////////////////////////////////////////////// pointLight.position.set(0, 100, 90);
            scene.add(pointLight);

            pointLight.color.setHSL(Math.random(), 1, 0.5);
            hex = decimalToHex(pointLight.color.getHex());
            //sky box says this
            var ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.3);
            //scene.add(ambientLight);

            materials = [
                new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    flatShading: true
                }), // front
                new THREE.MeshPhongMaterial({
                    color: 0xffffff
                }) // side
            ];
            group = new THREE.Group();
            group.position.y = 250;
            scene.add(group);


            // RENDERER
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            // STATS
            stats = new Stats();

            window.addEventListener('resize', onWindowResize, false);
            p1 = new HomeBall("blue", -200);
            //  scene.add(p1.get_mesh());
            p2 = new HomeBall("yellow", 0);
            //  scene.add(p2.get_mesh());
            p3 = new HomeBall("red", 200);
            //  scene.add(p3.get_mesh());

            updateState();
            AddInstructions();
            HelpInst();

            // scene.add(Newword.get_mesh());
            //  group.add(mesh1);

            // projector = new THREE.Projector();
            raycaster = new THREE.Raycaster();
            renderer.domElement.addEventListener('click', raycast, false);
            // when the mouse moves, call the given function
            // document.addEventListener('mousedown', onDocumentMouseDown, false);


            Players = [p1, p2, p3];
            //  initializeSkybox(50000, 5000, 5000);
            // console.log("MADE THE SKYBOX");

        }

        function raycast(e) {
            // Step 1: Detect light helper
            //1. sets the mouse position with a coordinate system where the center
            //   of the screen is the origin
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            //2. set the picking ray from the camera position and mouse coordinates
            raycaster.setFromCamera(mouse, camera);

            //3. compute intersections (note the 2nd parameter)
            // var intersects = raycaster.intersectObjects(scene.children, true);
            var intersects = raycaster.intersectObjects(scene.children, true);
            for (var i = 0; i < intersects.length; i++) {
                //  console.log(intersects[i]);
                /*
                    An intersection has the following properties :
                        - object : intersected object (THREE.Mesh)
                        - distance : distance from camera to intersection (number)
                        - face : intersected face (THREE.Face3)
                        - faceIndex : intersected face index (number)
                        - point : intersection point (THREE.Vector3)
                        - uv : intersection point in the object's UV coordinates (THREE.Vector2)
                */
            }
            // Step 2: Detect normal objects
            //1. sets the mouse position with a coordinate system where the center
            //   of the screen is the origin
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            //2. set the picking ray from the camera position and mouse coordinates
            raycaster.setFromCamera(mouse, camera);

            //3. compute intersections (no 2nd parameter true anymore)
            var intersects = raycaster.intersectObjects(scene.children);

            for (var i = 0; i < intersects.length; i++) {

                if (intersects[i].object == returnToMainB) {
                    state = 0;
                    updateState();
                    break;
                } else if (intersects[i].object == returnToMain) {
                    state = 0;
                    updateState();
                    break;
                } else if (state > 10) {} else if (intersects[i].object == p3.get_mesh()) {
                    if (state == 1) {
                        state = 13;
                        console.log("u hit hard");

                    } else if (state == 0) {
                        state = 3;
                        console.log("u hit exit");

                    }
                    updateState();
                    break;
                } else if (intersects[i].object == p2.get_mesh()) {
                    if (state == 0) { //pressed help
                        state = 2;
                        console.log("u hit help");
                    } else if (state == 1) {
                        state = 12;
                    }
                    updateState();
                    break;
                } else if (intersects[i].object == p1.get_mesh()) {
                    if (state == 0) {
                        state = 1;
                        console.log("u hit play");
                        updateState();
                        break;
                    } else if (state == 1) {
                        state = 11;
                        updateState();
                        break;
                    }
                }
                // change the color of the closest face.
                // intersects[0].material.emissive.setHex(0xdd0000);
                //  scene.remove(intersects[0]);
                // intersects[0].object.geometry.colorsNeedUpdate = true;
            }
        }

        function toString(v) {
            return "[ " + v.x + ", " + v.y + ", " + v.z + " ]";
        }

        function updateState() {
            if (state == 0) {
                loadFont("Colour Mix", "");
                p1.isReady = false;
                p2.isReady = false;
                p3.isReady = false;
                scene.remove(t1);
                scene.remove(t2);
                scene.remove(t3);
                scene.remove(returnToMain);
                scene.remove(textgroup);
                scene.remove(HelpRules);
                scene.remove(p1.get_mesh());
                scene.remove(p2.get_mesh());
                scene.remove(p3.get_mesh());
                console.log("t1" + t1);
                NewText("Play", -210, 1);
                //t1 = Tmesh;
                NewText("Help", -35, 2);
                NewText("Exit", 150, 3);
                console.log("t1" + t1);
                scene.add(p1.get_mesh());
                scene.add(p2.get_mesh());
                scene.add(p3.get_mesh());
            } else if (state == 1) {
                loadFont("Colour Mix", "    Select Difficulty");
                scene.remove(t1);
                scene.remove(t2);
                scene.remove(t3);
                scene.remove(returnToMain);
                NewText("Easy", -210, 1);
                NewText("Avg", -35, 2);
                NewText("Hard", 150, 3);
                NewText("Return To Main Screen", -180, 0);
            } else if (state == 2) {
                // loadFont("Colour Mix", "    Select Difficulty");
                scene.remove(p1.get_mesh());
                scene.remove(p2.get_mesh());
                scene.remove(p3.get_mesh());
                scene.remove(returnToMain);
                scene.remove(t1);
                scene.remove(t2);
                scene.remove(t3);
                scene.add(HelpRules);
                NewText("Return To Main Screen", -180, 0);
            } else if (state == 3) {
                //window.top.close(); does not work
                window.open('index.html', '_top', replace = true);

            } else if (state > 10) {
                loadFont("Colour Mix", "            Ready Up");
                //scene.remove(returnToMain);
                scene.remove(t1);
                scene.remove(t2);
                scene.remove(t3);
                NewText("P1", -190, 1);
                NewText("P2", -15, 2);
                NewText("P3", 160, 3);
                scene.add(textgroup);
                //scene.add(spritey);
            }
        }


        function onKeyDown(event) {
            event.stopPropagation();
            if (state > 10) {
                switch (event.keyCode) {
                    case 87:
                        /*W*/
                        p1.isReady = true;
                        scene.remove(p1.get_mesh());
                        //p1.objectClickHandler();
                        scene.remove(t1);
                        NewText("Ready", -190, 1);
                        checkReady();
                        break;
                    case 73:
                        /*I*/
                        p2.isReady = true;
                        scene.remove(p2.get_mesh());
                        //  p2.objectClickHandler();
                        scene.remove(t2);
                        NewText("Ready", -30, 2);
                        checkReady();
                        break;
                    case 38:
                        /*up*/
                        p3.isReady = true;
                        scene.remove(p3.get_mesh());
                        // p3.objectClickHandler();
                        scene.remove(t3);
                        (NewText("Ready", 170, 3));
                        checkReady();
                        break;
                }
            }
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function checkReady() {
            var tmp = true;
            Players.forEach(element => {
                if (element.isReady == false) {
                    tmp = false;
                    //  break;
                }
            });
            if (tmp) {
                console.log("hello!!!!!!!!");
                PlayGame();
                //load game
            }
        }

        function PlayGame() {
            window.open('game.html', '_top', replace = true);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
            updateSkybox();
            // stats.update();
        }

        function render() {
            camera.lookAt(cameraTarget);
            renderer.clear();
            renderer.render(scene, camera);
        }



        /*
        An intersection has the following properties :
            - object : intersected object (THREE.Mesh)
            - distance : distance from camera to intersection (number)
            - face : intersected face (THREE.Face3)
            - faceIndex : intersected face index (number)
            - point : intersection point (THREE.Vector3)
            - uv : intersection point in the object's UV coordinates (THREE.Vector2)
        */
        //   }

        //  }
        // function onDocumentMouseDown(event) {
        //     // the following line would stop any other event handler from firing
        //     // (such as the mouse's TrackballControls)
        //     // event.preventDefault();

        //     console.log("Click.");

        //     // update the mouse variable
        //     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        //     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        //     // find intersections
        //     // create a Ray with origin at the mouse position
        //     //   and direction into the scene (camera direction)
        //     var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
        //     projector.unprojectVector(vector, camera);
        //     var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
        //     // create an array containing all objects in the scene with which the ray intersects
        //     var intersects = ray.intersectObjects(targetList);

        //     // if there is one (or more) intersections
        //     if (intersects.length > 0) {
        //         console.log("Hit @ " + toString(intersects[0].point));
        //         // change the color of the closest face.
        //         intersects[0].face.color.setRGB(0.8 * Math.random() + 0.2, 0, 0);
        //         intersects[0].object.geometry.colorsNeedUpdate = true;
        //     }
        // }

        // function toString(v) {
        //     return "[ " + v.x + ", " + v.y + ", " + v.z + " ]";
        // }
    </script>

</body>

</html>